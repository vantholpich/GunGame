<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Hand Tracking Game</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: #000;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
            transform: scaleX(-1);
            /* Mirror effect */
        }

        #video-container {
            display: none;
        }

        #debug {
            position: absolute;
            top: 10px;
            right: 10px;
            /* Mirrored, so it will appear on left visually if we don't un-mirror text, but simpler to just place it */
            color: #0f0;
            font-family: monospace;
            font-size: 16px;
            z-index: 100;
            white-space: pre;
            pointer-events: none;
            text-shadow: 1px 1px 2px black;
        }

        /* Un-mirror the debug text container so it's readable */
        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 10;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"
        crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>
</head>

<body>
    <div id="video-container">
        <video class="input_video"></video>
    </div>
    <canvas class="output_canvas"></canvas>

    <div id="ui-layer">
        <div id="debug">Initializing...</div>
    </div>

    <script>
        const videoElement = document.getElementsByClassName('input_video')[0];
        const canvasElement = document.getElementsByClassName('output_canvas')[0];
        const canvasCtx = canvasElement.getContext('2d');
        const debugElement = document.getElementById('debug');

        // Game State
        let targets = [];
        let score = 0;
        let lastShotTime = 0;
        let isShooting = false;
        const SHOT_COOLDOWN = 500; // ms
        const PINCH_THRESHOLD = 0.05; // Relative distance

        // Setup Canvas Size
        function resizeCanvas() {
            canvasElement.width = window.innerWidth;
            canvasElement.height = window.innerHeight;
        }
        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        function spawnTarget() {
            const size = 50 + Math.random() * 50;
            targets.push({
                x: Math.random() * (1 - 0.2) + 0.1, // 10% to 90% width
                y: Math.random() * (0.8 - 0.2) + 0.2, // 20% to 80% height
                size: size,
                color: `hsl(${Math.random() * 360}, 70%, 50%)`,
                createdAt: Date.now(),
                lifeTime: 3000 + Math.random() * 2000
            });
        }

        // Spawn loop
        setInterval(() => {
            if (targets.length < 5) spawnTarget();
        }, 1500);

        // State for Recoil
        const RECOIL_THRESHOLD = 0.025; // Movement distance UP to trigger fire
        let prevIndexTipY = 0;
        let prevIndexTipX = 0;
        let lastGunPoseTime = 0;
        let lastValidTip = { x: 0, y: 0 }; // Track stable tip position

        function isFingerExtended(landmarks, fingerTipIdx, fingerPipIdx) {
            return landmarks[fingerTipIdx].y < landmarks[fingerPipIdx].y;
        }

        // Thumb is special, we check if tip is above IP (for "up")
        function isThumbUp(landmarks) {
            const thumbTip = landmarks[4];
            const thumbIP = landmarks[3];
            return thumbTip.y < thumbIP.y;
        }

        function isFingerCurled(landmarks, fingerTipIdx, fingerPipIdx) {
            return landmarks[fingerTipIdx].y > landmarks[fingerPipIdx].y;
        }

        function onResults(results) {
            canvasCtx.save();
            canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);

            // Draw Camera Feed
            canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

            // Game Logic
            const currentTime = Date.now();

            // Draw Targets
            // Note: Canvas is mirrored with CSS transform: scaleX(-1). 
            // targets = targets.filter(t => currentTime - t.createdAt < t.lifeTime); // Removed timeout logic

            targets.forEach(target => {
                const screenX = target.x * canvasElement.width;
                const screenY = target.y * canvasElement.height;

                canvasCtx.beginPath();
                canvasCtx.arc(screenX, screenY, target.size / 2, 0, 2 * Math.PI);
                canvasCtx.fillStyle = target.color;
                canvasCtx.fill();
                canvasCtx.lineWidth = 3;
                canvasCtx.strokeStyle = 'white';
                canvasCtx.stroke();

                // Bullseye
                canvasCtx.beginPath();
                canvasCtx.arc(screenX, screenY, target.size / 4, 0, 2 * Math.PI);
                canvasCtx.fillStyle = 'white';
                canvasCtx.fill();
            });

            // Hand Tracking
            let handDetected = false;
            let aimX = 0;
            let aimY = 0;

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                handDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // Draw Hand Landmarks and Connections
                // drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, { color: '#00FF00', lineWidth: 5 });
                // drawLandmarks(canvasCtx, landmarks, { color: '#FF0000', lineWidth: 2 });

                // Landmarks
                const indexTip = landmarks[8];
                const indexPIP = landmarks[6];
                const thumbTip = landmarks[4];
                const middleTip = landmarks[12];
                const middlePIP = landmarks[10];
                const ringTip = landmarks[16];
                const ringPIP = landmarks[14];
                const pinkyTip = landmarks[20];
                const pinkyPIP = landmarks[18];

                aimX = indexTip.x * canvasElement.width;
                aimY = indexTip.y * canvasElement.height;

                // Gun Pose Detection
                // Index Extended, Thumb Up, Others Curled
                const isThumbPointsUp = isThumbUp(landmarks);
                const isMiddleCurled = isFingerCurled(landmarks, 12, 10);
                const isRingCurled = isFingerCurled(landmarks, 16, 14);
                const isPinkyCurled = isFingerCurled(landmarks, 20, 18);

                const isGunPose = isThumbPointsUp && isMiddleCurled && isRingCurled && isPinkyCurled;

                let crosshairColor = '#FF0000'; // Red by default
                if (isGunPose) {
                    crosshairColor = '#00FF00'; // Green if ready
                    lastGunPoseTime = currentTime;
                    // Update stable tip position
                    lastValidTip = { x: indexTip.x, y: indexTip.y };
                }

                // Draw Crosshair
                canvasCtx.strokeStyle = crosshairColor;
                canvasCtx.lineWidth = 5;
                canvasCtx.beginPath();
                canvasCtx.arc(aimX, aimY, 20, 0, 2 * Math.PI);
                canvasCtx.stroke();

                // Draw Sight lines
                canvasCtx.beginPath();
                canvasCtx.moveTo(aimX - 30, aimY);
                canvasCtx.lineTo(aimX + 30, aimY);
                canvasCtx.moveTo(aimX, aimY - 30);
                canvasCtx.lineTo(aimX, aimY + 30);
                canvasCtx.stroke();

                // Debug info
                let debugText = `Score: ${score}\nGun Pose: ${isGunPose ? 'YES' : 'NO'}\nThumbUp: ${isThumbPointsUp}\nOthersCurled: ${isMiddleCurled && isRingCurled && isPinkyCurled}`;

                // Firing Logic: Recoil
                // Check if index tip moved UP rapidly while in Gun Pose (or recently in gun pose)

                const tipY = indexTip.y;
                const deltaY = prevIndexTipY - tipY; // Positive if moving UP (y decreasing)
                let rejectionReason = null;

                // Allow firing if we were in gun pose recently (within 500ms) 
                if (currentTime - lastGunPoseTime < 500) {
                    if (deltaY > RECOIL_THRESHOLD) {
                        const deltaX = Math.abs(prevIndexTipX - indexTip.x);
                        // Stability Check: Origin Check
                        const originDist = Math.hypot(prevIndexTipX - lastValidTip.x, prevIndexTipY - lastValidTip.y);

                        if (originDist > 0.2) {
                            rejectionReason = "BadOrigin";
                        } else if (!isShooting && currentTime - lastShotTime > SHOT_COOLDOWN) {
                            // FIRE!
                            isShooting = true;
                            lastShotTime = currentTime;
                            canvasCtx.fillStyle = 'rgba(255, 255, 0, 0.5)'; // Flash yellow

                            // Check Collision
                            // Use PREVIOUS tip positions (before recoil movement) for fresh, instant accuracy
                            const nAimX = prevIndexTipX;
                            const nAimY = prevIndexTipY;

                            let hit = false;
                            for (let i = targets.length - 1; i >= 0; i--) {
                                const t = targets[i];
                                const dx = (nAimX - t.x) * canvasElement.width;
                                const dy = (nAimY - t.y) * canvasElement.height;
                                const distPixels = Math.sqrt(dx * dx + dy * dy);

                                if (distPixels < t.size / 2) {
                                    targets.splice(i, 1);
                                    score += 10;
                                    hit = true;
                                    sendMessageToRN({ type: 'SCORE_UPDATE', score: score });
                                    break;
                                }
                            }
                        }
                    }
                }

                if (rejectionReason) {
                    debugText += `\nREJECT: ${rejectionReason}`;
                }
                debugElement.innerText = debugText;

                // Reset isShooting if we are not moving up fast anymore
                if (deltaY <= RECOIL_THRESHOLD / 2) {
                    isShooting = false;
                }

                prevIndexTipY = tipY;
                prevIndexTipX = indexTip.x;

            } else {
                debugElement.innerText = `Score: ${score}\nNo Hand Detected`;
                prevIndexTipY = 0;
                prevIndexTipX = 0;
            }

            canvasCtx.restore();
        }

        function sendMessageToRN(data) {
            if (window.ReactNativeWebView) {
                window.ReactNativeWebView.postMessage(JSON.stringify(data));
            }
        }

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults(onResults);

        const camera = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 1280,
            height: 720
        });

        camera.start().catch(e => {
            debugElement.innerText = "Camera failed: " + e;
        });

    </script>
</body>

</html>